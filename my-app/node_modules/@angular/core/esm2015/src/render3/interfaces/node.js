/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** @enum {number} */
const LNodeType = {
    Container: 0,
    Projection: 1,
    View: 2,
    Element: 3,
    ViewOrElement: 2,
};
export { LNodeType };
/** @enum {number} */
const TNodeFlags = {
    /** Whether or not this node is a component */
    Component: 1,
    /** How far to shift the flags to get the first directive index on this node */
    INDX_SHIFT: 13,
    /** How far to shift the flags to get the number of directives on this node */
    SIZE_SHIFT: 1,
    /** The amount to add to flags to increment size when each directive is added */
    SIZE_SKIP: 2,
    /** Mask to get the number of directives on this node */
    SIZE_MASK: 8190,
};
export { TNodeFlags };
/**
 * LNode is an internal data structure which is used for the incremental DOM algorithm.
 * The "L" stands for "Logical" to differentiate between `RNodes` (actual rendered DOM
 * node) and our logical representation of DOM nodes, `LNodes`.
 *
 * The data structure is optimized for speed and size.
 *
 * In order to be fast, all subtypes of `LNode` should have the same shape.
 * Because size of the `LNode` matters, many fields have multiple roles depending
 * on the `LNode` subtype.
 *
 * See: https://en.wikipedia.org/wiki/Inline_caching#Monomorphic_inline_caching
 *
 * NOTE: This is a private data structure and should not be exported by any of the
 * instructions.
 * @record
 */
export function LNode() { }
function LNode_tsickle_Closure_declarations() {
    /**
     * The type of the node (see LNodeFlags)
     * @type {?}
     */
    LNode.prototype.type;
    /**
     * The associated DOM node. Storing this allows us to:
     *  - append children to their element parents in the DOM (e.g. `parent.native.appendChild(...)`)
     *  - retrieve the sibling elements of text nodes whose creation / insertion has been delayed
     * @type {?}
     */
    LNode.prototype.native;
    /**
     * We need a reference to a node's parent so we can append the node to its parent's native
     * element at the appropriate time.
     * @type {?}
     */
    LNode.prototype.parent;
    /**
     * First child of the current node.
     * @type {?}
     */
    LNode.prototype.child;
    /**
     * The next sibling node. Necessary so we can propagate through the root nodes of a view
     * to insert them or remove them from the DOM.
     * @type {?}
     */
    LNode.prototype.next;
    /**
     * If regular LElementNode, then `data` will be null.
     * If LElementNode with component, then `data` contains LView.
     * If LViewNode, then `data` contains the LView.
     * If LContainerNode, then `data` contains LContainer.
     * If LProjectionNode, then `data` contains LProjection.
     * @type {?}
     */
    LNode.prototype.data;
    /**
     * Each node belongs to a view.
     *
     * When the injector is walking up a tree, it needs access to the `directives` (part of view).
     * @type {?}
     */
    LNode.prototype.view;
    /**
     * The injector associated with this node. Necessary for DI.
     * @type {?}
     */
    LNode.prototype.nodeInjector;
    /**
     * Optional set of queries that track query-related events for this node.
     *
     * If present the node creation/updates are reported to the `LQueries`.
     * @type {?}
     */
    LNode.prototype.queries;
    /**
     * If this node is projected, pointer to the next node in the same projection parent
     * (which is a container, an element, or a text node), or to the parent projection node
     * if this is the last node in the projection.
     * If this node is not projected, this field is null.
     * @type {?}
     */
    LNode.prototype.pNextOrParent;
    /**
     * Pointer to the corresponding TNode object, which stores static
     * data about this node.
     * @type {?}
     */
    LNode.prototype.tNode;
    /**
     * A pointer to a LContainerNode created by directives requesting ViewContainerRef
     * @type {?}
     */
    LNode.prototype.dynamicLContainerNode;
}
/**
 * LNode representing an element.
 * @record
 */
export function LElementNode() { }
function LElementNode_tsickle_Closure_declarations() {
    /**
     * The DOM element associated with this node.
     * @type {?}
     */
    LElementNode.prototype.native;
    /** @type {?} */
    LElementNode.prototype.child;
    /** @type {?} */
    LElementNode.prototype.next;
    /**
     * If Component then data has LView (light DOM)
     * @type {?}
     */
    LElementNode.prototype.data;
    /**
     * LElementNodes can be inside other LElementNodes or inside LViewNodes.
     * @type {?}
     */
    LElementNode.prototype.parent;
}
/**
 * LNode representing a #text node.
 * @record
 */
export function LTextNode() { }
function LTextNode_tsickle_Closure_declarations() {
    /**
     * The text node associated with this node.
     * @type {?}
     */
    LTextNode.prototype.native;
    /** @type {?} */
    LTextNode.prototype.child;
    /** @type {?} */
    LTextNode.prototype.next;
    /**
     * LTextNodes can be inside LElementNodes or inside LViewNodes.
     * @type {?}
     */
    LTextNode.prototype.parent;
    /** @type {?} */
    LTextNode.prototype.data;
    /** @type {?} */
    LTextNode.prototype.dynamicLContainerNode;
}
/**
 * Abstract node which contains root nodes of a view.
 * @record
 */
export function LViewNode() { }
function LViewNode_tsickle_Closure_declarations() {
    /** @type {?} */
    LViewNode.prototype.native;
    /** @type {?} */
    LViewNode.prototype.child;
    /** @type {?} */
    LViewNode.prototype.next;
    /**
     * LViewNodes can only be added to LContainerNodes.
     * @type {?}
     */
    LViewNode.prototype.parent;
    /** @type {?} */
    LViewNode.prototype.data;
    /** @type {?} */
    LViewNode.prototype.dynamicLContainerNode;
}
/**
 * Abstract node container which contains other views.
 * @record
 */
export function LContainerNode() { }
function LContainerNode_tsickle_Closure_declarations() {
    /** @type {?} */
    LContainerNode.prototype.native;
    /** @type {?} */
    LContainerNode.prototype.data;
    /** @type {?} */
    LContainerNode.prototype.child;
    /** @type {?} */
    LContainerNode.prototype.next;
    /**
     * Containers can be added to elements or views.
     * @type {?}
     */
    LContainerNode.prototype.parent;
}
/**
 * @record
 */
export function LProjectionNode() { }
function LProjectionNode_tsickle_Closure_declarations() {
    /** @type {?} */
    LProjectionNode.prototype.native;
    /** @type {?} */
    LProjectionNode.prototype.child;
    /** @type {?} */
    LProjectionNode.prototype.next;
    /** @type {?} */
    LProjectionNode.prototype.data;
    /**
     * Projections can be added to elements or views.
     * @type {?}
     */
    LProjectionNode.prototype.parent;
    /** @type {?} */
    LProjectionNode.prototype.dynamicLContainerNode;
}
/**
 * LNode binding data (flyweight) for a particular node that is shared between all templates
 * of a specific type.
 *
 * If a property is:
 *    - PropertyAliases: that property's data was generated and this is it
 *    - Null: that property's data was already generated and nothing was found.
 *    - Undefined: that property's data has not yet been generated
 *
 * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern
 * @record
 */
export function TNode() { }
function TNode_tsickle_Closure_declarations() {
    /**
     * This number stores two values using its bits:
     *
     * - the number of directives on that node (first 12 bits)
     * - the starting index of the node's directives in the directives array (last 20 bits).
     *
     * These two values are necessary so DI can effectively search the directives associated
     * with a node without searching the whole directives array.
     * @type {?}
     */
    TNode.prototype.flags;
    /**
     * The tag name associated with this node.
     * @type {?}
     */
    TNode.prototype.tagName;
    /**
     * Static attributes associated with an element. We need to store
     * static attributes to support content projection with selectors.
     * Attributes are stored statically because reading them from the DOM
     * would be way too slow for content projection and queries.
     *
     * Since attrs will always be calculated first, they will never need
     * to be marked undefined by other instructions.
     *
     * The name of the attribute and its value alternate in the array.
     * e.g. ['role', 'checkbox']
     * @type {?}
     */
    TNode.prototype.attrs;
    /**
     * A set of local names under which a given element is exported in a template and
     * visible to queries. An entry in this array can be created for different reasons:
     * - an element itself is referenced, ex.: `<div #foo>`
     * - a component is referenced, ex.: `<my-cmpt #foo>`
     * - a directive is referenced, ex.: `<my-cmpt #foo="directiveExportAs">`.
     *
     * A given element might have different local names and those names can be associated
     * with a directive. We store local names at even indexes while odd indexes are reserved
     * for directive index in a view (or `-1` if there is no associated directive).
     *
     * Some examples:
     * - `<div #foo>` => `["foo", -1]`
     * - `<my-cmpt #foo>` => `["foo", myCmptIdx]`
     * - `<my-cmpt #foo #bar="directiveExportAs">` => `["foo", myCmptIdx, "bar", directiveIdx]`
     * - `<div #foo #bar="directiveExportAs">` => `["foo", -1, "bar", directiveIdx]`
     * @type {?}
     */
    TNode.prototype.localNames;
    /**
     * Information about input properties that need to be set once from attribute data.
     * @type {?}
     */
    TNode.prototype.initialInputs;
    /**
     * Input data for all directives on this node.
     *
     * - `undefined` means that the prop has not been initialized yet,
     * - `null` means that the prop has been initialized but no inputs have been found.
     * @type {?}
     */
    TNode.prototype.inputs;
    /**
     * Output data for all directives on this node.
     *
     * - `undefined` means that the prop has not been initialized yet,
     * - `null` means that the prop has been initialized but no outputs have been found.
     * @type {?}
     */
    TNode.prototype.outputs;
    /**
     * The static data equivalent of LNode.data.
     *
     * If this TNode corresponds to an LContainerNode, the container will
     * need to store separate static data for each of its views (TContainer).
     *
     * If this TNode corresponds to an LElementNode, data will be null.
     * @type {?}
     */
    TNode.prototype.data;
}
/**
 * Static data for an LElementNode
 * @record
 */
export function TElementNode() { }
function TElementNode_tsickle_Closure_declarations() {
    /** @type {?} */
    TElementNode.prototype.data;
}
/**
 * Static data for an LContainerNode
 * @record
 */
export function TContainerNode() { }
function TContainerNode_tsickle_Closure_declarations() {
    /** @type {?} */
    TContainerNode.prototype.data;
}
// Note: This hack is necessary so we don't erroneously get a circular dependency
// failure based on types.
export const /** @type {?} */ unusedValueExportToPlacateAjd = 1;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL3JlbmRlcjMvaW50ZXJmYWNlcy9ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK1dBLE1BQU0sQ0FBQyx1QkFBTSw2QkFBNkIsR0FBRyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7TENvbnRhaW5lciwgVENvbnRhaW5lcn0gZnJvbSAnLi9jb250YWluZXInO1xuaW1wb3J0IHtMSW5qZWN0b3J9IGZyb20gJy4vaW5qZWN0b3InO1xuaW1wb3J0IHtMUHJvamVjdGlvbn0gZnJvbSAnLi9wcm9qZWN0aW9uJztcbmltcG9ydCB7TFF1ZXJpZXN9IGZyb20gJy4vcXVlcnknO1xuaW1wb3J0IHtSRWxlbWVudCwgUk5vZGUsIFJUZXh0fSBmcm9tICcuL3JlbmRlcmVyJztcbmltcG9ydCB7TFZpZXcsIFREYXRhLCBUVmlld30gZnJvbSAnLi92aWV3JztcblxuXG5cbi8qKlxuICogTE5vZGVUeXBlIGNvcnJlc3BvbmRzIHRvIHRoZSBMTm9kZS50eXBlIHByb3BlcnR5LiBJdCBjb250YWlucyBpbmZvcm1hdGlvblxuICogb24gaG93IHRvIG1hcCBhIHBhcnRpY3VsYXIgc2V0IG9mIGJpdHMgaW4gTE5vZGUuZmxhZ3MgdG8gdGhlIG5vZGUgdHlwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gTE5vZGVUeXBlIHtcbiAgQ29udGFpbmVyID0gMGIwMCxcbiAgUHJvamVjdGlvbiA9IDBiMDEsXG4gIFZpZXcgPSAwYjEwLFxuICBFbGVtZW50ID0gMGIxMSxcbiAgVmlld09yRWxlbWVudCA9IDBiMTAsXG59XG5cbi8qKlxuICogVE5vZGVGbGFncyBjb3JyZXNwb25kcyB0byB0aGUgVE5vZGUuZmxhZ3MgcHJvcGVydHkuIEl0IGNvbnRhaW5zIGluZm9ybWF0aW9uXG4gKiBvbiBob3cgdG8gbWFwIGEgcGFydGljdWxhciBzZXQgb2YgYml0cyB0byB0aGUgbm9kZSdzIGZpcnN0IGRpcmVjdGl2ZSBpbmRleFxuICogKHdpdGggSU5EWF9TSElGVCkgb3IgdGhlIG5vZGUncyBkaXJlY3RpdmUgY291bnQgKHdpdGggU0laRV9NQVNLKVxuICovXG5leHBvcnQgY29uc3QgZW51bSBUTm9kZUZsYWdzIHtcbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBpcyBhIGNvbXBvbmVudCAqL1xuICBDb21wb25lbnQgPSAwYjAwMSxcblxuICAvKiogSG93IGZhciB0byBzaGlmdCB0aGUgZmxhZ3MgdG8gZ2V0IHRoZSBmaXJzdCBkaXJlY3RpdmUgaW5kZXggb24gdGhpcyBub2RlICovXG4gIElORFhfU0hJRlQgPSAxMyxcblxuICAvKiogSG93IGZhciB0byBzaGlmdCB0aGUgZmxhZ3MgdG8gZ2V0IHRoZSBudW1iZXIgb2YgZGlyZWN0aXZlcyBvbiB0aGlzIG5vZGUgKi9cbiAgU0laRV9TSElGVCA9IDEsXG5cbiAgLyoqIFRoZSBhbW91bnQgdG8gYWRkIHRvIGZsYWdzIHRvIGluY3JlbWVudCBzaXplIHdoZW4gZWFjaCBkaXJlY3RpdmUgaXMgYWRkZWQgKi9cbiAgU0laRV9TS0lQID0gMixcblxuICAvKiogTWFzayB0byBnZXQgdGhlIG51bWJlciBvZiBkaXJlY3RpdmVzIG9uIHRoaXMgbm9kZSAqL1xuICBTSVpFX01BU0sgPSAwYjAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTExMTExMTEwXG59XG5cbi8qKlxuICogTE5vZGUgaXMgYW4gaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgdXNlZCBmb3IgdGhlIGluY3JlbWVudGFsIERPTSBhbGdvcml0aG0uXG4gKiBUaGUgXCJMXCIgc3RhbmRzIGZvciBcIkxvZ2ljYWxcIiB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gYFJOb2Rlc2AgKGFjdHVhbCByZW5kZXJlZCBET01cbiAqIG5vZGUpIGFuZCBvdXIgbG9naWNhbCByZXByZXNlbnRhdGlvbiBvZiBET00gbm9kZXMsIGBMTm9kZXNgLlxuICpcbiAqIFRoZSBkYXRhIHN0cnVjdHVyZSBpcyBvcHRpbWl6ZWQgZm9yIHNwZWVkIGFuZCBzaXplLlxuICpcbiAqIEluIG9yZGVyIHRvIGJlIGZhc3QsIGFsbCBzdWJ0eXBlcyBvZiBgTE5vZGVgIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlLlxuICogQmVjYXVzZSBzaXplIG9mIHRoZSBgTE5vZGVgIG1hdHRlcnMsIG1hbnkgZmllbGRzIGhhdmUgbXVsdGlwbGUgcm9sZXMgZGVwZW5kaW5nXG4gKiBvbiB0aGUgYExOb2RlYCBzdWJ0eXBlLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5saW5lX2NhY2hpbmcjTW9ub21vcnBoaWNfaW5saW5lX2NhY2hpbmdcbiAqXG4gKiBOT1RFOiBUaGlzIGlzIGEgcHJpdmF0ZSBkYXRhIHN0cnVjdHVyZSBhbmQgc2hvdWxkIG5vdCBiZSBleHBvcnRlZCBieSBhbnkgb2YgdGhlXG4gKiBpbnN0cnVjdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTE5vZGUge1xuICAvKiogVGhlIHR5cGUgb2YgdGhlIG5vZGUgKHNlZSBMTm9kZUZsYWdzKSAqL1xuICB0eXBlOiBMTm9kZVR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZSBhc3NvY2lhdGVkIERPTSBub2RlLiBTdG9yaW5nIHRoaXMgYWxsb3dzIHVzIHRvOlxuICAgKiAgLSBhcHBlbmQgY2hpbGRyZW4gdG8gdGhlaXIgZWxlbWVudCBwYXJlbnRzIGluIHRoZSBET00gKGUuZy4gYHBhcmVudC5uYXRpdmUuYXBwZW5kQ2hpbGQoLi4uKWApXG4gICAqICAtIHJldHJpZXZlIHRoZSBzaWJsaW5nIGVsZW1lbnRzIG9mIHRleHQgbm9kZXMgd2hvc2UgY3JlYXRpb24gLyBpbnNlcnRpb24gaGFzIGJlZW4gZGVsYXllZFxuICAgKi9cbiAgcmVhZG9ubHkgbmF0aXZlOiBSRWxlbWVudHxSVGV4dHxudWxsfHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogV2UgbmVlZCBhIHJlZmVyZW5jZSB0byBhIG5vZGUncyBwYXJlbnQgc28gd2UgY2FuIGFwcGVuZCB0aGUgbm9kZSB0byBpdHMgcGFyZW50J3MgbmF0aXZlXG4gICAqIGVsZW1lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHRpbWUuXG4gICAqL1xuICByZWFkb25seSBwYXJlbnQ6IExOb2RlfG51bGw7XG5cbiAgLyoqXG4gICAqIEZpcnN0IGNoaWxkIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAqL1xuICBjaGlsZDogTE5vZGV8bnVsbDtcblxuICAvKipcbiAgICogVGhlIG5leHQgc2libGluZyBub2RlLiBOZWNlc3Nhcnkgc28gd2UgY2FuIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSByb290IG5vZGVzIG9mIGEgdmlld1xuICAgKiB0byBpbnNlcnQgdGhlbSBvciByZW1vdmUgdGhlbSBmcm9tIHRoZSBET00uXG4gICAqL1xuICBuZXh0OiBMTm9kZXxudWxsO1xuXG4gIC8qKlxuICAgKiBJZiByZWd1bGFyIExFbGVtZW50Tm9kZSwgdGhlbiBgZGF0YWAgd2lsbCBiZSBudWxsLlxuICAgKiBJZiBMRWxlbWVudE5vZGUgd2l0aCBjb21wb25lbnQsIHRoZW4gYGRhdGFgIGNvbnRhaW5zIExWaWV3LlxuICAgKiBJZiBMVmlld05vZGUsIHRoZW4gYGRhdGFgIGNvbnRhaW5zIHRoZSBMVmlldy5cbiAgICogSWYgTENvbnRhaW5lck5vZGUsIHRoZW4gYGRhdGFgIGNvbnRhaW5zIExDb250YWluZXIuXG4gICAqIElmIExQcm9qZWN0aW9uTm9kZSwgdGhlbiBgZGF0YWAgY29udGFpbnMgTFByb2plY3Rpb24uXG4gICAqL1xuICByZWFkb25seSBkYXRhOiBMVmlld3xMQ29udGFpbmVyfExQcm9qZWN0aW9ufG51bGw7XG5cblxuICAvKipcbiAgICogRWFjaCBub2RlIGJlbG9uZ3MgdG8gYSB2aWV3LlxuICAgKlxuICAgKiBXaGVuIHRoZSBpbmplY3RvciBpcyB3YWxraW5nIHVwIGEgdHJlZSwgaXQgbmVlZHMgYWNjZXNzIHRvIHRoZSBgZGlyZWN0aXZlc2AgKHBhcnQgb2YgdmlldykuXG4gICAqL1xuICByZWFkb25seSB2aWV3OiBMVmlldztcblxuICAvKiogVGhlIGluamVjdG9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuIE5lY2Vzc2FyeSBmb3IgREkuICovXG4gIG5vZGVJbmplY3RvcjogTEluamVjdG9yfG51bGw7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHNldCBvZiBxdWVyaWVzIHRoYXQgdHJhY2sgcXVlcnktcmVsYXRlZCBldmVudHMgZm9yIHRoaXMgbm9kZS5cbiAgICpcbiAgICogSWYgcHJlc2VudCB0aGUgbm9kZSBjcmVhdGlvbi91cGRhdGVzIGFyZSByZXBvcnRlZCB0byB0aGUgYExRdWVyaWVzYC5cbiAgICovXG4gIHF1ZXJpZXM6IExRdWVyaWVzfG51bGw7XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgbm9kZSBpcyBwcm9qZWN0ZWQsIHBvaW50ZXIgdG8gdGhlIG5leHQgbm9kZSBpbiB0aGUgc2FtZSBwcm9qZWN0aW9uIHBhcmVudFxuICAgKiAod2hpY2ggaXMgYSBjb250YWluZXIsIGFuIGVsZW1lbnQsIG9yIGEgdGV4dCBub2RlKSwgb3IgdG8gdGhlIHBhcmVudCBwcm9qZWN0aW9uIG5vZGVcbiAgICogaWYgdGhpcyBpcyB0aGUgbGFzdCBub2RlIGluIHRoZSBwcm9qZWN0aW9uLlxuICAgKiBJZiB0aGlzIG5vZGUgaXMgbm90IHByb2plY3RlZCwgdGhpcyBmaWVsZCBpcyBudWxsLlxuICAgKi9cbiAgcE5leHRPclBhcmVudDogTE5vZGV8bnVsbDtcblxuICAvKipcbiAgICogUG9pbnRlciB0byB0aGUgY29ycmVzcG9uZGluZyBUTm9kZSBvYmplY3QsIHdoaWNoIHN0b3JlcyBzdGF0aWNcbiAgICogZGF0YSBhYm91dCB0aGlzIG5vZGUuXG4gICAqL1xuICB0Tm9kZTogVE5vZGV8bnVsbDtcblxuICAvKipcbiAgICogQSBwb2ludGVyIHRvIGEgTENvbnRhaW5lck5vZGUgY3JlYXRlZCBieSBkaXJlY3RpdmVzIHJlcXVlc3RpbmcgVmlld0NvbnRhaW5lclJlZlxuICAgKi9cbiAgZHluYW1pY0xDb250YWluZXJOb2RlOiBMQ29udGFpbmVyTm9kZXxudWxsO1xufVxuXG5cbi8qKiBMTm9kZSByZXByZXNlbnRpbmcgYW4gZWxlbWVudC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTEVsZW1lbnROb2RlIGV4dGVuZHMgTE5vZGUge1xuICAvKiogVGhlIERPTSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuICovXG4gIHJlYWRvbmx5IG5hdGl2ZTogUkVsZW1lbnQ7XG5cbiAgY2hpbGQ6IExDb250YWluZXJOb2RlfExFbGVtZW50Tm9kZXxMVGV4dE5vZGV8TFByb2plY3Rpb25Ob2RlfG51bGw7XG4gIG5leHQ6IExDb250YWluZXJOb2RlfExFbGVtZW50Tm9kZXxMVGV4dE5vZGV8TFByb2plY3Rpb25Ob2RlfG51bGw7XG5cbiAgLyoqIElmIENvbXBvbmVudCB0aGVuIGRhdGEgaGFzIExWaWV3IChsaWdodCBET00pICovXG4gIHJlYWRvbmx5IGRhdGE6IExWaWV3fG51bGw7XG5cbiAgLyoqIExFbGVtZW50Tm9kZXMgY2FuIGJlIGluc2lkZSBvdGhlciBMRWxlbWVudE5vZGVzIG9yIGluc2lkZSBMVmlld05vZGVzLiAqL1xuICByZWFkb25seSBwYXJlbnQ6IExFbGVtZW50Tm9kZXxMVmlld05vZGU7XG59XG5cbi8qKiBMTm9kZSByZXByZXNlbnRpbmcgYSAjdGV4dCBub2RlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMVGV4dE5vZGUgZXh0ZW5kcyBMTm9kZSB7XG4gIC8qKiBUaGUgdGV4dCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuICovXG4gIG5hdGl2ZTogUlRleHQ7XG4gIGNoaWxkOiBudWxsO1xuICBuZXh0OiBMQ29udGFpbmVyTm9kZXxMRWxlbWVudE5vZGV8TFRleHROb2RlfExQcm9qZWN0aW9uTm9kZXxudWxsO1xuXG4gIC8qKiBMVGV4dE5vZGVzIGNhbiBiZSBpbnNpZGUgTEVsZW1lbnROb2RlcyBvciBpbnNpZGUgTFZpZXdOb2Rlcy4gKi9cbiAgcmVhZG9ubHkgcGFyZW50OiBMRWxlbWVudE5vZGV8TFZpZXdOb2RlO1xuICByZWFkb25seSBkYXRhOiBudWxsO1xuICBkeW5hbWljTENvbnRhaW5lck5vZGU6IG51bGw7XG59XG5cbi8qKiBBYnN0cmFjdCBub2RlIHdoaWNoIGNvbnRhaW5zIHJvb3Qgbm9kZXMgb2YgYSB2aWV3LiAqL1xuZXhwb3J0IGludGVyZmFjZSBMVmlld05vZGUgZXh0ZW5kcyBMTm9kZSB7XG4gIHJlYWRvbmx5IG5hdGl2ZTogbnVsbDtcbiAgY2hpbGQ6IExDb250YWluZXJOb2RlfExFbGVtZW50Tm9kZXxMVGV4dE5vZGV8TFByb2plY3Rpb25Ob2RlfG51bGw7XG4gIG5leHQ6IExWaWV3Tm9kZXxudWxsO1xuXG4gIC8qKiAgTFZpZXdOb2RlcyBjYW4gb25seSBiZSBhZGRlZCB0byBMQ29udGFpbmVyTm9kZXMuICovXG4gIHJlYWRvbmx5IHBhcmVudDogTENvbnRhaW5lck5vZGV8bnVsbDtcbiAgcmVhZG9ubHkgZGF0YTogTFZpZXc7XG4gIGR5bmFtaWNMQ29udGFpbmVyTm9kZTogbnVsbDtcbn1cblxuLyoqIEFic3RyYWN0IG5vZGUgY29udGFpbmVyIHdoaWNoIGNvbnRhaW5zIG90aGVyIHZpZXdzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMQ29udGFpbmVyTm9kZSBleHRlbmRzIExOb2RlIHtcbiAgLypcbiAgICogQ2FjaGVzIHRoZSByZWZlcmVuY2Ugb2YgdGhlIGZpcnN0IG5hdGl2ZSBub2RlIGZvbGxvd2luZyB0aGlzIGNvbnRhaW5lciBpbiB0aGUgc2FtZSBuYXRpdmVcbiAgICogcGFyZW50LlxuICAgKiBUaGlzIGlzIHJlc2V0IHRvIHVuZGVmaW5lZCBpbiBjb250YWluZXJSZWZyZXNoRW5kLlxuICAgKiBXaGVuIGl0IGlzIHVuZGVmaW5lZCwgaXQgbWVhbnMgdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjb21wdXRlZCB5ZXQuXG4gICAqIE90aGVyd2lzZSwgaXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiBmaW5kQmVmb3JlTm9kZShjb250YWluZXIsIG51bGwpLlxuICAgKi9cbiAgbmF0aXZlOiBSRWxlbWVudHxSVGV4dHxudWxsfHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgZGF0YTogTENvbnRhaW5lcjtcbiAgY2hpbGQ6IG51bGw7XG4gIG5leHQ6IExDb250YWluZXJOb2RlfExFbGVtZW50Tm9kZXxMVGV4dE5vZGV8TFByb2plY3Rpb25Ob2RlfG51bGw7XG5cbiAgLyoqIENvbnRhaW5lcnMgY2FuIGJlIGFkZGVkIHRvIGVsZW1lbnRzIG9yIHZpZXdzLiAqL1xuICByZWFkb25seSBwYXJlbnQ6IExFbGVtZW50Tm9kZXxMVmlld05vZGV8bnVsbDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIExQcm9qZWN0aW9uTm9kZSBleHRlbmRzIExOb2RlIHtcbiAgcmVhZG9ubHkgbmF0aXZlOiBudWxsO1xuICBjaGlsZDogbnVsbDtcbiAgbmV4dDogTENvbnRhaW5lck5vZGV8TEVsZW1lbnROb2RlfExUZXh0Tm9kZXxMUHJvamVjdGlvbk5vZGV8bnVsbDtcblxuICByZWFkb25seSBkYXRhOiBMUHJvamVjdGlvbjtcblxuICAvKiogUHJvamVjdGlvbnMgY2FuIGJlIGFkZGVkIHRvIGVsZW1lbnRzIG9yIHZpZXdzLiAqL1xuICByZWFkb25seSBwYXJlbnQ6IExFbGVtZW50Tm9kZXxMVmlld05vZGU7XG4gIGR5bmFtaWNMQ29udGFpbmVyTm9kZTogbnVsbDtcbn1cblxuLyoqXG4gKiBMTm9kZSBiaW5kaW5nIGRhdGEgKGZseXdlaWdodCkgZm9yIGEgcGFydGljdWxhciBub2RlIHRoYXQgaXMgc2hhcmVkIGJldHdlZW4gYWxsIHRlbXBsYXRlc1xuICogb2YgYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIElmIGEgcHJvcGVydHkgaXM6XG4gKiAgICAtIFByb3BlcnR5QWxpYXNlczogdGhhdCBwcm9wZXJ0eSdzIGRhdGEgd2FzIGdlbmVyYXRlZCBhbmQgdGhpcyBpcyBpdFxuICogICAgLSBOdWxsOiB0aGF0IHByb3BlcnR5J3MgZGF0YSB3YXMgYWxyZWFkeSBnZW5lcmF0ZWQgYW5kIG5vdGhpbmcgd2FzIGZvdW5kLlxuICogICAgLSBVbmRlZmluZWQ6IHRoYXQgcHJvcGVydHkncyBkYXRhIGhhcyBub3QgeWV0IGJlZW4gZ2VuZXJhdGVkXG4gKlxuICogc2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbHl3ZWlnaHRfcGF0dGVybiBmb3IgbW9yZSBvbiB0aGUgRmx5d2VpZ2h0IHBhdHRlcm5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUTm9kZSB7XG4gIC8qKlxuICAgKiBUaGlzIG51bWJlciBzdG9yZXMgdHdvIHZhbHVlcyB1c2luZyBpdHMgYml0czpcbiAgICpcbiAgICogLSB0aGUgbnVtYmVyIG9mIGRpcmVjdGl2ZXMgb24gdGhhdCBub2RlIChmaXJzdCAxMiBiaXRzKVxuICAgKiAtIHRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgbm9kZSdzIGRpcmVjdGl2ZXMgaW4gdGhlIGRpcmVjdGl2ZXMgYXJyYXkgKGxhc3QgMjAgYml0cykuXG4gICAqXG4gICAqIFRoZXNlIHR3byB2YWx1ZXMgYXJlIG5lY2Vzc2FyeSBzbyBESSBjYW4gZWZmZWN0aXZlbHkgc2VhcmNoIHRoZSBkaXJlY3RpdmVzIGFzc29jaWF0ZWRcbiAgICogd2l0aCBhIG5vZGUgd2l0aG91dCBzZWFyY2hpbmcgdGhlIHdob2xlIGRpcmVjdGl2ZXMgYXJyYXkuXG4gICAqL1xuICBmbGFnczogVE5vZGVGbGFncztcblxuICAvKiogVGhlIHRhZyBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuICovXG4gIHRhZ05hbWU6IHN0cmluZ3xudWxsO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggYW4gZWxlbWVudC4gV2UgbmVlZCB0byBzdG9yZVxuICAgKiBzdGF0aWMgYXR0cmlidXRlcyB0byBzdXBwb3J0IGNvbnRlbnQgcHJvamVjdGlvbiB3aXRoIHNlbGVjdG9ycy5cbiAgICogQXR0cmlidXRlcyBhcmUgc3RvcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSByZWFkaW5nIHRoZW0gZnJvbSB0aGUgRE9NXG4gICAqIHdvdWxkIGJlIHdheSB0b28gc2xvdyBmb3IgY29udGVudCBwcm9qZWN0aW9uIGFuZCBxdWVyaWVzLlxuICAgKlxuICAgKiBTaW5jZSBhdHRycyB3aWxsIGFsd2F5cyBiZSBjYWxjdWxhdGVkIGZpcnN0LCB0aGV5IHdpbGwgbmV2ZXIgbmVlZFxuICAgKiB0byBiZSBtYXJrZWQgdW5kZWZpbmVkIGJ5IG90aGVyIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBhbmQgaXRzIHZhbHVlIGFsdGVybmF0ZSBpbiB0aGUgYXJyYXkuXG4gICAqIGUuZy4gWydyb2xlJywgJ2NoZWNrYm94J11cbiAgICovXG4gIGF0dHJzOiBzdHJpbmdbXXxudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBsb2NhbCBuYW1lcyB1bmRlciB3aGljaCBhIGdpdmVuIGVsZW1lbnQgaXMgZXhwb3J0ZWQgaW4gYSB0ZW1wbGF0ZSBhbmRcbiAgICogdmlzaWJsZSB0byBxdWVyaWVzLiBBbiBlbnRyeSBpbiB0aGlzIGFycmF5IGNhbiBiZSBjcmVhdGVkIGZvciBkaWZmZXJlbnQgcmVhc29uczpcbiAgICogLSBhbiBlbGVtZW50IGl0c2VsZiBpcyByZWZlcmVuY2VkLCBleC46IGA8ZGl2ICNmb28+YFxuICAgKiAtIGEgY29tcG9uZW50IGlzIHJlZmVyZW5jZWQsIGV4LjogYDxteS1jbXB0ICNmb28+YFxuICAgKiAtIGEgZGlyZWN0aXZlIGlzIHJlZmVyZW5jZWQsIGV4LjogYDxteS1jbXB0ICNmb289XCJkaXJlY3RpdmVFeHBvcnRBc1wiPmAuXG4gICAqXG4gICAqIEEgZ2l2ZW4gZWxlbWVudCBtaWdodCBoYXZlIGRpZmZlcmVudCBsb2NhbCBuYW1lcyBhbmQgdGhvc2UgbmFtZXMgY2FuIGJlIGFzc29jaWF0ZWRcbiAgICogd2l0aCBhIGRpcmVjdGl2ZS4gV2Ugc3RvcmUgbG9jYWwgbmFtZXMgYXQgZXZlbiBpbmRleGVzIHdoaWxlIG9kZCBpbmRleGVzIGFyZSByZXNlcnZlZFxuICAgKiBmb3IgZGlyZWN0aXZlIGluZGV4IGluIGEgdmlldyAob3IgYC0xYCBpZiB0aGVyZSBpcyBubyBhc3NvY2lhdGVkIGRpcmVjdGl2ZSkuXG4gICAqXG4gICAqIFNvbWUgZXhhbXBsZXM6XG4gICAqIC0gYDxkaXYgI2Zvbz5gID0+IGBbXCJmb29cIiwgLTFdYFxuICAgKiAtIGA8bXktY21wdCAjZm9vPmAgPT4gYFtcImZvb1wiLCBteUNtcHRJZHhdYFxuICAgKiAtIGA8bXktY21wdCAjZm9vICNiYXI9XCJkaXJlY3RpdmVFeHBvcnRBc1wiPmAgPT4gYFtcImZvb1wiLCBteUNtcHRJZHgsIFwiYmFyXCIsIGRpcmVjdGl2ZUlkeF1gXG4gICAqIC0gYDxkaXYgI2ZvbyAjYmFyPVwiZGlyZWN0aXZlRXhwb3J0QXNcIj5gID0+IGBbXCJmb29cIiwgLTEsIFwiYmFyXCIsIGRpcmVjdGl2ZUlkeF1gXG4gICAqL1xuICBsb2NhbE5hbWVzOiAoc3RyaW5nfG51bWJlcilbXXxudWxsO1xuXG4gIC8qKiBJbmZvcm1hdGlvbiBhYm91dCBpbnB1dCBwcm9wZXJ0aWVzIHRoYXQgbmVlZCB0byBiZSBzZXQgb25jZSBmcm9tIGF0dHJpYnV0ZSBkYXRhLiAqL1xuICBpbml0aWFsSW5wdXRzOiBJbml0aWFsSW5wdXREYXRhfG51bGx8dW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBJbnB1dCBkYXRhIGZvciBhbGwgZGlyZWN0aXZlcyBvbiB0aGlzIG5vZGUuXG4gICAqXG4gICAqIC0gYHVuZGVmaW5lZGAgbWVhbnMgdGhhdCB0aGUgcHJvcCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LFxuICAgKiAtIGBudWxsYCBtZWFucyB0aGF0IHRoZSBwcm9wIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ1dCBubyBpbnB1dHMgaGF2ZSBiZWVuIGZvdW5kLlxuICAgKi9cbiAgaW5wdXRzOiBQcm9wZXJ0eUFsaWFzZXN8bnVsbHx1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE91dHB1dCBkYXRhIGZvciBhbGwgZGlyZWN0aXZlcyBvbiB0aGlzIG5vZGUuXG4gICAqXG4gICAqIC0gYHVuZGVmaW5lZGAgbWVhbnMgdGhhdCB0aGUgcHJvcCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LFxuICAgKiAtIGBudWxsYCBtZWFucyB0aGF0IHRoZSBwcm9wIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ1dCBubyBvdXRwdXRzIGhhdmUgYmVlbiBmb3VuZC5cbiAgICovXG4gIG91dHB1dHM6IFByb3BlcnR5QWxpYXNlc3xudWxsfHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIHN0YXRpYyBkYXRhIGVxdWl2YWxlbnQgb2YgTE5vZGUuZGF0YS5cbiAgICpcbiAgICogSWYgdGhpcyBUTm9kZSBjb3JyZXNwb25kcyB0byBhbiBMQ29udGFpbmVyTm9kZSwgdGhlIGNvbnRhaW5lciB3aWxsXG4gICAqIG5lZWQgdG8gc3RvcmUgc2VwYXJhdGUgc3RhdGljIGRhdGEgZm9yIGVhY2ggb2YgaXRzIHZpZXdzIChUQ29udGFpbmVyKS5cbiAgICpcbiAgICogSWYgdGhpcyBUTm9kZSBjb3JyZXNwb25kcyB0byBhbiBMRWxlbWVudE5vZGUsIGRhdGEgd2lsbCBiZSBudWxsLlxuICAgKi9cbiAgZGF0YTogVENvbnRhaW5lcnxudWxsO1xufVxuXG4vKiogU3RhdGljIGRhdGEgZm9yIGFuIExFbGVtZW50Tm9kZSAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVEVsZW1lbnROb2RlIGV4dGVuZHMgVE5vZGUgeyBkYXRhOiBudWxsOyB9XG5cbi8qKiBTdGF0aWMgZGF0YSBmb3IgYW4gTENvbnRhaW5lck5vZGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVENvbnRhaW5lck5vZGUgZXh0ZW5kcyBUTm9kZSB7IGRhdGE6IFRDb250YWluZXI7IH1cblxuLyoqXG4gKiBUaGlzIG1hcHBpbmcgaXMgbmVjZXNzYXJ5IHNvIHdlIGNhbiBzZXQgaW5wdXQgcHJvcGVydGllcyBhbmQgb3V0cHV0IGxpc3RlbmVyc1xuICogcHJvcGVybHkgYXQgcnVudGltZSB3aGVuIHByb3BlcnR5IG5hbWVzIGFyZSBtaW5pZmllZCBvciBhbGlhc2VkLlxuICpcbiAqIEtleTogdW5taW5pZmllZCAvIHB1YmxpYyBpbnB1dCBvciBvdXRwdXQgbmFtZVxuICogVmFsdWU6IGFycmF5IGNvbnRhaW5pbmcgbWluaWZpZWQgLyBpbnRlcm5hbCBuYW1lIGFuZCByZWxhdGVkIGRpcmVjdGl2ZSBpbmRleFxuICpcbiAqIFRoZSB2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IHRvIHN1cHBvcnQgaW5wdXRzIGFuZCBvdXRwdXRzIHdpdGggdGhlIHNhbWUgbmFtZVxuICogb24gdGhlIHNhbWUgbm9kZS5cbiAqL1xuZXhwb3J0IHR5cGUgUHJvcGVydHlBbGlhc2VzID0ge1xuICAvLyBUaGlzIHVzZXMgYW4gb2JqZWN0IG1hcCBiZWNhdXNlIHVzaW5nIHRoZSBNYXAgdHlwZSB3b3VsZCBiZSB0b28gc2xvd1xuICBba2V5OiBzdHJpbmddOiBQcm9wZXJ0eUFsaWFzVmFsdWVcbn07XG5cbi8qKlxuICogU3RvcmUgdGhlIHJ1bnRpbWUgaW5wdXQgb3Igb3V0cHV0IG5hbWVzIGZvciBhbGwgdGhlIGRpcmVjdGl2ZXMuXG4gKlxuICogLSBFdmVuIGluZGljZXM6IGRpcmVjdGl2ZSBpbmRleFxuICogLSBPZGQgaW5kaWNlczogbWluaWZpZWQgLyBpbnRlcm5hbCBuYW1lXG4gKlxuICogZS5nLiBbMCwgJ2NoYW5nZS1taW5pZmllZCddXG4gKi9cbmV4cG9ydCB0eXBlIFByb3BlcnR5QWxpYXNWYWx1ZSA9IChudW1iZXIgfCBzdHJpbmcpW107XG5cblxuLyoqXG4gKiBUaGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGlucHV0IHByb3BlcnRpZXMgdGhhdFxuICogbmVlZCB0byBiZSBzZXQgb25jZSBmcm9tIGF0dHJpYnV0ZSBkYXRhLiBJdCdzIG9yZGVyZWQgYnlcbiAqIGRpcmVjdGl2ZSBpbmRleCAocmVsYXRpdmUgdG8gZWxlbWVudCkgc28gaXQncyBzaW1wbGUgdG9cbiAqIGxvb2sgdXAgYSBzcGVjaWZpYyBkaXJlY3RpdmUncyBpbml0aWFsIGlucHV0IGRhdGEuXG4gKlxuICogV2l0aGluIGVhY2ggc3ViLWFycmF5OlxuICpcbiAqIEV2ZW4gaW5kaWNlczogbWluaWZpZWQvaW50ZXJuYWwgaW5wdXQgbmFtZVxuICogT2RkIGluZGljZXM6IGluaXRpYWwgdmFsdWVcbiAqXG4gKiBJZiBhIGRpcmVjdGl2ZSBvbiBhIG5vZGUgZG9lcyBub3QgaGF2ZSBhbnkgaW5wdXQgcHJvcGVydGllc1xuICogdGhhdCBzaG91bGQgYmUgc2V0IGZyb20gYXR0cmlidXRlcywgaXRzIGluZGV4IGlzIHNldCB0byBudWxsXG4gKiB0byBhdm9pZCBhIHNwYXJzZSBhcnJheS5cbiAqXG4gKiBlLmcuIFtudWxsLCBbJ3JvbGUtbWluJywgJ2J1dHRvbiddXVxuICovXG5leHBvcnQgdHlwZSBJbml0aWFsSW5wdXREYXRhID0gKEluaXRpYWxJbnB1dHMgfCBudWxsKVtdO1xuXG4vKipcbiAqIFVzZWQgYnkgSW5pdGlhbElucHV0RGF0YSB0byBzdG9yZSBpbnB1dCBwcm9wZXJ0aWVzXG4gKiB0aGF0IHNob3VsZCBiZSBzZXQgb25jZSBmcm9tIGF0dHJpYnV0ZXMuXG4gKlxuICogRXZlbiBpbmRpY2VzOiBtaW5pZmllZC9pbnRlcm5hbCBpbnB1dCBuYW1lXG4gKiBPZGQgaW5kaWNlczogaW5pdGlhbCB2YWx1ZVxuICpcbiAqIGUuZy4gWydyb2xlLW1pbicsICdidXR0b24nXVxuICovXG5leHBvcnQgdHlwZSBJbml0aWFsSW5wdXRzID0gc3RyaW5nW107XG5cbi8vIE5vdGU6IFRoaXMgaGFjayBpcyBuZWNlc3Nhcnkgc28gd2UgZG9uJ3QgZXJyb25lb3VzbHkgZ2V0IGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuLy8gZmFpbHVyZSBiYXNlZCBvbiB0eXBlcy5cbmV4cG9ydCBjb25zdCB1bnVzZWRWYWx1ZUV4cG9ydFRvUGxhY2F0ZUFqZCA9IDE7XG4iXX0=